# [题目链接](https://leetcode-cn.com/problems/unique-paths/)

本题示例2的解释有错误：
原始示例2为：
```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

应该改为：
```
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```
吐槽下力扣中文题目的翻译工作做的有点点粗糙，这个题就不说了，许多题目还漏翻译了约束条件(Constraints)，这对于解题是很重要的信息。

## 解析

### 思路1：计算组合数

对于 $m\times n$ 大小的网格而言，机器人从网格的左上角到右下角共需要移动 $m + n - 2$ 步，而每次移动的方向只能是向下或者向右，那么我们可以得出 $m+n-2$ 步中包含向下 $m - 1$ 步，向右 $n - 1$ 步。从而我们可以把该题看作典型的组合问题，我们将机器人走的 $m + n - 2$ 步都编上号，从 $1$ 到 $m + n -2$，我们从中选出 $m - 1$ 步向下，$n - 1$ 步向右，则选择方案的个数为组合数：
$$
C_{m + n - 2}^{m - 1}=C_{m+n-2}^{n-1}=\frac{(m+n-2)!}{(m-1)!(n-1!)}
$$

到目前为止这个题目只用到了高中排列组合部分的数学知识，组合数公式也很简单，只需要计算几个阶乘即可。但其实阶乘是一个很麻烦的运算，我们高中处理的排列组合问题规模都比较小，甚至可以手算出排列数/组合数的答案。但是实际问题中的阶乘的结果可能是一个天文数字，所以就没那么容易得到结果了。

对于本题而言，当 $m=10$ 和 $n=10$，$(m+n-2)!=18!=6,402,373,705,728,000$，大于 `int` 的最大值 `2147483647`，$m=23$ 和 $n=12$，阶乘的计算结果会超出 `long long int` 的最大值。所以本题直接利用更宽的数据类型保存阶乘的方式不可行。

我采取的方式是对组合数公式进行约分：
$$
C_{m + n - 2}^{m - 1}=C_{m+n-2}^{n-1}=\frac{(m+n-2)!}{(m-1)!(n-1!)}=\frac{(n-1)\times(n-1+1)\times\cdots\times(m+n-2)}{1\times2\times\cdots\times(m-1)}
$$

得到上式后，我们将分母看作一个数组 `A`，分子看做一个数组 `B`，数组的每一项保存一个乘数，譬如分母的数组 `A` 可以表示为：`{1, 2, ..., m - 1}`，可以发现数组 `A` 和 `B` 的大小相同。从而接下来的问题便是如何求两个数组各自所有元素的乘积的商。问题到这，有点类似于[21. 合并两个有序链表](https://github.com/wtyuan96/LeetCode-Solutions/blob/main/solutions/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.md)，可以利用两个指向两个数组头端的指针，遍历数组。

另外，我们为了避免溢出（ `int` 还是会溢出，但是 `long long int` 不会），不是把每个数组的所有元素全部乘起来，而是看作如下形式：
$$
\frac{(n-1)\times(n-1+1)\times\cdots\times(m+n-2)}{1\times2\times\cdots\times(m-1)}=\frac{n-1}{1}\times\frac{n-1+1}{2}\times \cdots \times \frac{m+n-2}{m-1}
$$
如上式进行计算则不会溢出，但可能会出现小数（看了官方题解[[1]](#1-不同路径-官方题解)直接用了 `long long int` 才知道不可能出现小数，对组合数理解的还是不透彻！），我选择用 `double` 存储结果，最终浮点转整型，作为最终输出。

* 时间复杂度：$O(\min(m, n))$，官方题解的C++实现，漏加了交换 $m$ 和 $n$ 的一行代码。
* 空间复杂度：$O(1)$

### 思路2：动态规划

## 实现

### C++

#### 思路1

```C++
class Solution {
public:
   int uniquePaths(int m, int n) {
       if (m > n) return uniquePaths(n, m);  // 确保时间复杂度为O(min(m, n))
       int left1 = n - 1 + 1, right1 = m + n - 2, left2 = 1, right2 = m - 1;
       double ans = 1;  // 实际上可以用long long int 存储，不会出现小数。
       while (left1 <= right1) {
           ans *= left1++;  // 指针后移，两个数组大小相同。
           ans /= left2++;
       }
       return ans;
   }
};
```

## 参考

####  [[1] 不同路径 官方题解](https://leetcode-cn.com/problems/unique-paths/solution/)


## TODO list
- [ ] 思路2动态规划解析及代码