# [题目链接](https://leetcode-cn.com/problems/power-of-two/)

## 解析

这道题目的方法应该非常多。

### 思路1：查找表

有点类似于 FPGA 中的查找表，用一个数组将32位宽范围内的2的幂次方都存储下来。给定一个整数，只需要遍历数组依次比对即可判断它是否是2的幂次方。在 FPGA 中实现乘除法比较耗时，有时会将计算耗时的运算结果存储下来，譬如正弦查找表。

* 时间复杂度：$O(w)$，$w$ 表示 `n` 的位宽。
* 空间复杂度：需要 $O(w)$ 大小的数组存储2的幂次方数据。
### 思路2：遍历二进制数

若一个数为2的幂次方，则这个数的二进制数的最高位一定为1，且（若存在）其它位为0。

给定一个整数 `n`，首先对2取余，判读取余结果是否为0，若取余结果不为0，判断 `n` 是否为1，如果不为1则说明 `n` 一定不为2的幂次方。若取余结果为0，说明 `n` 的二进制的最低位为0，那么将 `n` 右移一位，继续判断取余结果是否为0。最终当取余结果不为0的时候，判断此时的 `n` 是否为1，若为1则说明最高位为1（且其它位为0），则 `n` 为2的幂次方。

* 时间复杂度：$O(w)$
* 空间复杂度：$O(1)$

### 思路3：位运算

位运算博大精深，如果运用得好，可以大大降低时间复杂度。尤其是针对硬件的编程。

* `x & (-x)`\
  计算机是采用补码表示数字，正数的补码等于原码，复数的补码等于原码取反加1。根据补码表示法，`-x=~x + 1`，那么 `x` 与 `-x` 的按位与结果会只保留最右侧的1（可以参考题解[[1]](#1-2的幂-官方题解)的图示）。若 `x` 为2的幂，`x` 应该只包含一个1，即 `x & -x` 等于 `x`。

* `x & (x - 1)`\
  `x - 1` 会使得 `x` 最右侧的1及这个1右侧的位全部取反，从而 `x & (x - 1)` 会将最右侧的1置为0，其余位不变（可以参考题解[[1]](#1-2的幂-官方题解)的图示）。若 `x` 为2的幂，`x` 应该只包含一个1，即 `x & (-x)` 等于0。

## 实现

### C++

#### 思路1：查找表

```C++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        int a[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};
        for(int i = 0; i < 31; i++){
            if(n == a[i]) return true;
        }
        return false;
    }
};
```

#### 思路2：遍历二进制数

```C++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return false;
        while (n % 2 == 0) {
            n = n >> 1;
        }
        return n == 1;
    }
};
```

#### 思路3：位运算

```C++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return 0;
        return (n & (-n)) == n;
    }
};
```

```C++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if (n <= 0) return 0;
        return (n & (n - 1)) == 0;
    }
};
```

## 参考

####  [[1] 2的幂 官方题解](https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode/)